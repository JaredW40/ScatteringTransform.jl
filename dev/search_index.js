var documenterSearchIndex = {"docs":
[{"location":"struct/#scatteringTransform-type","page":"scatteringTransform type","title":"scatteringTransform type","text":"","category":"section"},{"location":"struct/#Parameters-unique-to-ScatteringTransform.jl","page":"scatteringTransform type","title":"Parameters unique to ScatteringTransform.jl","text":"m::Integer=2: the total number of layers\nnormalize::Bool=true: if true, apply the function normalize. The amount of energy in each layer decays exponentially for most inputs, so without normalizing, using the scattering coefficients poses some difficulty. To avoid this, when normalize is true, each layer is divided by the overall norm of that layer, and then multiplied by the number of paths in that layer.\npoolBy::Union{<:Integer, <:Rational, <:Tuple}=3//2: the amount to pool between layers. For a two layer network, the default is expanded to (3//2, 3//2, 3//2), corresponding to the first layer, second layer, and final averaging subsampling rates. It also accepts tuples that are too short, and simply replicates the last entry, e.g. poolBy=(2,3//2) for a three layer network is equivalent to poolBy=(2,3//2,3//2,3//2).\noutputPool::Union{<:Integer, <:Rational, <:Tuple}=2: the amount to subsample after averaging in each layer (present because averaging removes the high frequencies, so the full signal is inherently redundant). Has a similar structure to poolBy.\nflatten::Bool=false: if true, return a matrix that is (nCoefficients,nExamples), otherwise, return the more structured ScatteredOut\nσ::function=abs: the nonlinearity applied pointwise between layers. This should take in a Number, and return a Number (real or complex floating point). If the wavelet transform is analytic, this must have a method for Complex.","category":"section"},{"location":"struct/#Parameters-passed-to-[FourierFilterFlux.jl](https://dsweber2.github.io/FourierFilterFlux.jl/dev/)","page":"scatteringTransform type","title":"Parameters passed to FourierFilterFlux.jl","text":"dtype::DataType=Float32: the data type used to represent the filters.\ncw::ContWaveClass=Morlet(): the type of wavelet to use.\nplan::Bool=true: if true, store the fft plan for reuse.\nconvBoundary::ConvBoundary=Sym(): the type of symmetry to use in computing the transform. Note that convBoundary and boundary are different, with boundary needing to be set using types from ContinuousWavelets and convBoundary needs to be set using the FourierFilterFlux types.\naveragingLayer::Bool=false: if true, use just the averaging filter, and drop all other filters.\ntrainable::Bool=false: if true, the wavelet filters are considered parameters, and can be updated using standard methods from Flux.jl.\nbias::Bool=false: if true, include an offset, initialized using init. Most likely to be used with trainable true.\ninit::function=Flux.glorot_normal: a function to initialize the bias, otherwise ignored.","category":"section"},{"location":"struct/#Parameters-passed-to-[ContinuousWavelets.jl](https://dsweber2.github.io/ContinuousWavelets.jl/dev/)","page":"scatteringTransform type","title":"Parameters passed to ContinuousWavelets.jl","text":"scalingFactor, s, or Q::Real=8.0: the number of wavelets between the octaves 2^J and 2^J+1 (defaults to 8, which is most appropriate for music and other audio). Valid range is (0infty).\nβ::Real=4.0: As using exactly Q wavelets per octave leads to excessively many low-frequency wavelets, β varies the number of wavelets per octave, with larger values of β corresponding to fewer low frequency wavelets(see Wavelet Frequency Spacing for details). Valid range is (1infty), though around β=6 the spacing is approximately linear in frequency, rather than log-frequency, and begins to become concave after that.\nboundary::WaveletBoundary=SymBoundary(): The default boundary condition is SymBoundary(), implemented by appending a flipped version of the vector at the end to eliminate edge discontinuities. See Boundary Conditions for the other possibilities. \naveragingType::Average=Father(): determines whether or not to include the averaging function, and if so, what kind of averaging. The options are\nFather: use the averaging function that corresponds to the mother Wavelet.\nDirac: use the sinc function with the appropriate width.\nNoAve: don't average. this has one fewer filters than the other averagingTypes\naveragingLength::Int=4:  the number of wavelet octaves that are covered by the averaging, \nframeBound::Real=1: gives the total norm of the whole collection, corresponding to the upper frame bound; if you don't want to impose a particular bound, set frameBound<0.\nnormalization or p::Real=Inf: the p-norm preserved as the scale changes, so if we're scaling by s, normalization has value p, and the mother wavelet is psi, then the resulting wavelet is s^1ppsi(^t_s). The default scaling, Inf gives all the same maximum value in the frequency domain. Valid range is (0infty, though p1 isn't actually preserving a norm.","category":"section"},{"location":"struct/#ScatteringTransform.scatteringTransform","page":"scatteringTransform type","title":"ScatteringTransform.scatteringTransform","text":"scatteringTransform{Dimension,Depth}\n\nThe abstract type and constructor for scattering transforms. The specific types are stFlux in this package, and stParallel in ParallelScattering.jl.\n\n\n\n\n\n","category":"type"},{"location":"struct/#ScatteringTransform.scatteringTransform-Tuple{Any, Any, UnionAll}","page":"scatteringTransform type","title":"ScatteringTransform.scatteringTransform","text":"scatteringTransform(inputSize, m=2, backend::UnionAll=stFlux; kwargs...)\n\nThe constructor for the abstract type scatteringTransform, with the concrete type specified by backend.\n\n\n\n\n\n","category":"method"},{"location":"struct/#ScatteringTransform.stFlux","page":"scatteringTransform type","title":"ScatteringTransform.stFlux","text":"stFlux(inputSize::NTuple{N}, m=2; outputPool = 2, poolBy = 3//2, \nσ = abs, normalize = true, flatten = false, trainable = false, kwargs...) \nwhere {N}\n\nCreate a complete setting of scattering transform that can be applied to a set of input signals\n\nInput Arguments\n\ninputSize::NTuple{N}: The size of the input signals. It should be of NTuple\n\ntype. For example, for a set of M 1D signals each of which has length N,  it should be (N, 1, M). For a set of M 2D signals each of which is of size  N₁ × N₂, it should be (N₁, N₂, 1, M). Note that the input signal array  that will be transformed by the output function from this stFlux must have the same dimension structure as this inputSize::NTuple{N}. E.g., if the input 1D signals are arrange as a matrix of size (N, M), it must be converted to an  array of size (N, 1, M) using reshape function before applying the transform.\n\nm=2: The maximum depth of the scattering transform. The default value is 2.\n\nNote that the depth (or layer) index starts with 0. So, this scattering transform sets up m+1 layers.\n\noutputPool = 2: Subsampling rate after averaging in each layer (it's present\n\nhere because averaging removes the high frequencies, so the full signal is inherently redundant). Can specify different subsampling rates for each direction for 2D input signals with e.g., outputPool=(2,3). Has a similar structure to poolBy.\n\npoolBy = 3//2: Subsampling rate at each layer for the intermediate representation.\n\nThe default value is 3//2 for each layer. Layer-dependent rates can be specified by supplying NTuple, e.g., (3//2, 2, 3) for 0th, 1st, and 2nd layers.\n\nσ = abs: The nonlinearity function used. The default function is abs, i.e.,\n\ncomputing the modulus.\n\nnormalize = true: If it's true, it gives each layer the same average weight\n\nper path, e.g., norm 1 for the 0th layer (since it has only one path), norm 16 for the 1st layer paths (if the first layer has 16 paths), etc. This is primarily for cases where the classification algorithm needs roughly the same order of  magnitude variance. \n\nflatten = false: If false, it returns a result that is a matrix of size \n\n(:,nExamples) where nExamples is the last dimension of inputSize. If it's true, then return a matrix that is (nCoefficients,nExamples).\n\ntrainable = false: If it's true, the wavelet filters can be viewed as \n\nweights (or parameters) to be learned and updated using standard methods from Flux.jl. For the standard scattering transform scenarios, it should stay as false.\n\nkwargs...: come from either the FourierFilterFlux \n\nwaveletLayerConstructor,  or from ContinuousWavlets wavelet constructor ContinuousWavelets. Note that by default, the Morlet wavelet filters are used, but one can change it by supplying, e.g., cw=dog2 (Difference of Gaussian or the Mexican Hat Wavelet).\n\nOutput Argument:\n\nstFlux data structure (also works as a function to apply the scattering transform on\n\nan input signal set) whose main parameters are:\n\nNd: Number of spatial dimension of the input signal set\nm: The maximus depth index\nfilters: \nσ: The nonlinearity operation function\nbatchSize: Number of the input signals\nnormalize: a flag to normalize the output coefficients\n\nExamples\n\njulia> using ScatteringTransform\n\njulia> x = [ones(128); zeros(128)];\n\njulia> St = stFlux((256,1,1))\n┌ Warning: there are wavelets whose peaks are far enough apart that the trough between them is less than half the height of the highest frequency wavelet\n│   minimalRegionComparedToLastPeak = 7.0515\n└ @ ContinuousWavelets ~/.julia/packages/ContinuousWavelets/KeITS/src/sanityChecks.jl:33\n┌ Warning: there are wavelets whose peaks are far enough apart that the trough between them is less than half the height of the highest frequency wavelet\n│   minimalRegionComparedToLastPeak = 4.815\n└ @ ContinuousWavelets ~/.julia/packages/ContinuousWavelets/KeITS/src/sanityChecks.jl:33\n┌ Warning: there are wavelets whose peaks are far enough apart that the trough between them is less than half the height of the highest frequency wavelet\n│   minimalRegionComparedToLastPeak = 3.2091\n└ @ ContinuousWavelets ~/.julia/packages/ContinuousWavelets/KeITS/src/sanityChecks.jl:33\nstFlux{Nd=1, m=2, filters=[12, 11], σ = abs, batchSize = 1, normalize = true}\n\njulia> St(x)\nScatteredOut{Array{Float32},3} 1 dim. OutputSizes:\n    (128, 1, 1)\n    (86, 12, 1)\n    (57, 11, 12, 1)\n\n\n\n\n\n\n","category":"type"},{"location":"subsampling/#Subsampling-Operators","page":"Subsampling Operators","title":"Subsampling Operators","text":"","category":"section"},{"location":"subsampling/#Subsampling-Utilities","page":"Subsampling Operators","title":"Subsampling Utilities","text":"","category":"section"},{"location":"subsampling/#ScatteringTransform.RationPool","page":"Subsampling Operators","title":"ScatteringTransform.RationPool","text":"RationPool{A,B}\n\nAn extension of Flux's MaxPool and MeanPool to subsampling by rational amounts as well. Don't construct directly. Has fields r.m, which is the pooling operator as implemented in Flux, and r.resSize, which gives the subsampling rates, either as Integer, Rational, or tuples of these.\n\nIt works by first applying the given pooling operator, but with a step size of 1, and then keeping p out of q entries, where p is the numerator of the rational rate, and q is the denominator.\n\n\n\n\n\n","category":"type"},{"location":"subsampling/#ScatteringTransform.RationPool-Union{Tuple{NTuple{N, Union{Integer, Rational}}}, Tuple{N}, Tuple{NTuple{N, Union{Integer, Rational}}, Any}} where N","page":"Subsampling Operators","title":"ScatteringTransform.RationPool","text":"RationPool(resSize, k=2; nExtraDims=1, poolType = MeanPool)\n\nConstruct a RationPool instance, which is a slight extension of the Flux pooling methods to subsample at a rational rate resSize, which can vary by channel.  For example, for a 2D input, resSize could be (2,3//2), 3//2 (equivalent to (3//2, 3//2)), or (5//3, 5//3).\n\nk is the window size of the pooling, and poolType is the type of pooling,  either MaxPool or MeanPool. nExtraDims counts the number of dimensions  uninvolved in the convolution; normally this is 2, as in (..., nChannels, nExamples). You can expect pooling to work for sizes up to 5 total dimensions.\n\n\n\n\n\n","category":"method"},{"location":"subsampling/#ScatteringTransform.poolSize","page":"Subsampling Operators","title":"ScatteringTransform.poolSize","text":"poolSize(k::RationPool, sizes)\npoolSize(k, sizs)\n\nReturn the number should we expect in the output with pooling rates k in each dimension (e.g. (3//2, 3//2) or RationPool((3//2,3//2))).\n\n\n\n\n\n","category":"function"},{"location":"pathLocs/#Path-Operations","page":"Path Operations","title":"Path Operations","text":"To make working with paths somewhat easier, in addition to indexing ScatteringOut by layer and then raw index, there is the pathLocs type:\n\njulia> using ScatteringTransform, Wavelets, Logging\n\njulia> St = with_logger(NullLogger()) do\n           scatteringTransform((1024,1,1),2)\n       end\nstFlux{Nd=1, m=2, filters=[15, 14], σ = abs, batchSize = 1, normalize = true}\n\njulia> s = St(testfunction(1024, \"Doppler\"))\nScatteredOut{Array{Float32},3} 1 dim. OutputSizes:\n    (512, 1, 1)\n    (342, 15, 1)\n    (228, 14, 15, 1)\n\njulia> p = pathLocs(2, (3,5))\npathLocs{3}((nothing, nothing, (Colon(), 3, 5, Colon())))\n\njulia> s[p]\n228×1 Matrix{Float32}:\n 0.09841786\n 0.10313512\n ⋮\n 0.00073056365\n 0.00075656467\n\np above for example, accesses the second layer path (3,5) (3 being the second layer index and 5 being the first layer index). The first entry specifies the layer, and the second specifies which entries in that layer.\n\njulia> p1 = pathLocs(2, (:,3))\npathLocs{3}((nothing, nothing, (Colon(), Colon(), 3, Colon())))\n\njulia> s[p1]\n228×14×1 Array{Float32, 3}:\n[:, :, 1] =\n 24.4596     0.121606    …  0.000137235  0.000253008\n 24.442      0.133231       0.000137483  0.000266736\n  ⋮                      ⋱\n  0.0143983  0.00752869     3.26755f-5   7.5444f-5\n  0.0145095  0.00778378     3.2883f-5    7.69233f-5\n\np1 grabs every path where the first layer index is 3.\n\nWe can also grab multiple layers using a single path:\n\njulia> p2 = pathLocs(1, (5,), 2, (1,:))\npathLocs{3}((nothing, (Colon(), 5, Colon()), (Colon(), 1, Colon(), Colon())))\n\njulia> s[p2][1]\n342×1 Matrix{Float32}:\n 0.10331459\n 0.10902256\n ⋮\n 0.00016353851\n 0.00016699042\n\njulia> s[p2][2]\n228×15×1 Array{Float32, 3}:\n[:, :, 1] =\n 0.0620106  9.75739    …  4.02497      3.14531\n 0.0652926  9.90173       4.0116       3.1348\n ⋮                     ⋱\n 0.589259   0.0193751     0.000606986  0.000488191\n 0.590126   0.0195244     0.000613764  0.000493479\n\njulia> p3 = pathLocs(1, s)\npathLocs{3}([(); (); … ; (); ();;;])","category":"section"},{"location":"pathLocs/#ScatteringTransform.pathLocs","page":"Path Operations","title":"ScatteringTransform.pathLocs","text":"struct pathLocs{m}\n    indices\nend\npathLocs(varargs...; m::Int=2, d::Int=1, exs=Colon())\n\nThe general constructor for path locs. The general pattern is alternating integers and tuples, with the integers corresponding to accessed layers, and the tuples to the paths accessed in that layer.\n\npathLocs(s::scattered)\n\nmake a pathLocs that accesses every location in the output.\n\n\n\n\n\n","category":"type"},{"location":"pathLocs/#ScatteringTransform.nonZeroPaths","page":"Path Operations","title":"ScatteringTransform.nonZeroPaths","text":"nonZeroPaths(sc; wholePath=true, allTogetherInOne=false)\n\nGiven a Scattered, return the pathLocs where the Scattered is nonzero. wholePath=true if it returns the whole path, and not just the specific location in the signal. For example, if only sc(pathLocs(1,(30,2))) is nonzero, if wholePath is true, then pathLocs(1,(2,)) will be returned while if wholePath is false, pathLocs(1,(30,2)) will be returned instead. if allTogetherInOne is false, then each location is returned separately, otherwise they are joined into a single pathLocs.\n\n\n\n\n\n","category":"function"},{"location":"pathLocs/#ScatteringTransform.computeLoc","page":"Path Operations","title":"ScatteringTransform.computeLoc","text":"p = computeLoc(loc, toRoll, st::stFlux)\n\ngiven a location loc in the flattened output toRoll, return a pathLocs describing that location in the rolled version\n\n\n\n\n\n","category":"function"},{"location":"plots/#Plotting-Scattering-Transforms","page":"Plotting Utilities","title":"Plotting Scattering Transforms","text":"","category":"section"},{"location":"plots/#ScatteringTransform.gifFirstLayer","page":"Plotting Utilities","title":"ScatteringTransform.gifFirstLayer","text":"gifFirstLayer(origLoc, origSig, saveTo=\"tmp.gif\", fps = 2, index)\n\nFunction to create a GIF visualizing all wavelets in the first layer across space for each example in the batch.  The variable origLoc is the ScatteredOut object containing the scattering transform results, index specifies which example in the batch to plot,  origSig is the original input signal, saveTo specifies the file path to save the GIF, and fps sets the frames per second for the GIF animation. \n\n\n\n\n\n","category":"function"},{"location":"plots/#ScatteringTransform.jointPlot-NTuple{4, Any}","page":"Plotting Utilities","title":"ScatteringTransform.jointPlot","text":"jointPlot(thingToPlot, thingName, cSymbol, St; sharedColorScaling=:exp, targetExample=1, δt=1000, freqigdigits=3, sharedColorbar=false, extraPlot=nothing, allPositive=false, logPower=false)\n\nCreate a joint plot visualizing the zeroth, first, and second layer scattering results for a specified example. The variable thingToPlot is a tuple containing the scattering results for the  zeroth, first, and second layers, thingName is the title for the plot, cSymbol specifies the color gradient to use, and St is the scattering transform object. The function allows for  various customization options, including shared color scaling, target example selection, frequency digit rounding, and additional plotting options. \n\n\n\n\n\n","category":"method"},{"location":"plots/#ScatteringTransform.plotFirstLayer","page":"Plotting Utilities","title":"ScatteringTransform.plotFirstLayer","text":"plotFirstLayer(stw, St, saveTo=\"gradientFigures/firstLayer.png\", index=1)\n\nFunction that creates a heatmap of the first layer scattering transform results at a specified example index.  The variable stw is the scattered output, St is the scattering transform object, saveTo is the file  path to save the plot, and index specifies which example in the batch to plot.\n\n\n\n\n\n","category":"function"},{"location":"plots/#ScatteringTransform.plotFirstLayer1D","page":"Plotting Utilities","title":"ScatteringTransform.plotFirstLayer1D","text":"plotFirstLayer1D(j, origLoc, origSig, index)\n\nFunction that plots the first layer gradient wavelet at index j across space, along with the original signal.  It also includes heatmaps of the gradient wavelet in both the spatial and frequency domains.  The variable j specifies which wavelet to plot from the first layer, index specifies which example in the batch to plot,  origLoc is the ScatteredOut object containing the scattering transform results, and origSig is the original input signal. \n\n\n\n\n\n","category":"function"},{"location":"plots/#ScatteringTransform.plotFirstLayer1DAll","page":"Plotting Utilities","title":"ScatteringTransform.plotFirstLayer1DAll","text":"plotFirstLayer1DAll(origLoc, origSig, saveTo=\"gradientFigures/tmp2.png\", index=1, cline=:darkrainbow)\n\nFunction that plots all first layer gradient wavelets for a specific example signal index across space, along with the original signal.  It also includes heatmaps of the gradient wavelets in both the spatial and frequency domains.  The variable index specifies which example in the batch to plot, origLoc is the ScatteredOut object  containing the scattering transform results, origSig is the original input signal, and saveTo is the file path to save the plot.\n\n\n\n\n\n","category":"function"},{"location":"plots/#ScatteringTransform.plotSecondLayer","page":"Plotting Utilities","title":"ScatteringTransform.plotSecondLayer","text":"plotSecondLayer(stw, St, index=1; title=\"Second Layer results\", xVals=-1, yVals=-1, logPower=true, toHeat=nothing, c=cgrad(:viridis, [0,.9]), threshold=0, linePalette=:greys, minLog=NaN, kwargs...)\n\nTODO fix the similarity of these names. xVals and yVals give the spacing of the grid, as it doesn't seem to be done correctly by default. xVals gives the distance from the left and the right as a tuple, while yVals gives the distance from the top and the bottom, also as a tuple. Default values are xVals = (.037, .852), yVals = (.056, .939), or if you have no title, use xVals = (.0105, .882), yVals = (.056, .939) If you have no colorbar, set xVals = (.0015, .997), yVals = (.002, .992) In the case that arbitrary space has been introduced, if you have a title, use xVals = (.037, .852), yVals = (.056, .939), or if you have no title, use xVals = (.0105, .882), yVals = (.056, .939)\n\n\n\n\n\n","category":"function"},{"location":"plots/#ScatteringTransform.plotSecondLayer1D","page":"Plotting Utilities","title":"ScatteringTransform.plotSecondLayer1D","text":"plotSecondLayer1D(loc, origLoc, wave1, wave2, original=false, subsamSz=(128,85,))\n\n\n\n\n\n","category":"function"},{"location":"plots/#ScatteringTransform.plotSecondLayer1DSubsetGif","page":"Plotting Utilities","title":"ScatteringTransform.plotSecondLayer1DSubsetGif","text":"plotSecondLayer1DSubsetGif(stw, St, firstLayerWavelets, secondLayerWavelets, original, saveTo=\"secondLayerFigures/tmp2.gif\", fps=2, index=1)\n\nCreate a GIF visualizing the second layer scattering results for specified subsets of wavelets from the first and second layers. The variables firstLayerWavelets and secondLayerWavelets are arrays  containing the indices of the wavelets to be visualized from the first and second layers, respectively. For example, to visualize all the wavelets from the first layer with respect to a specific  wavelet from the second layer, you can set firstLayerWavelets = 1:size(stw[1], 2) and secondLayerWavelets = k, where k is the index of the desired second layer wavelet. Once again, the index  parameter specifies which example in the batch to plot. It defaults to the first example in the batch. \n\n\n\n\n\n","category":"function"},{"location":"plots/#ScatteringTransform.plotSecondLayerFixAndVary","page":"Plotting Utilities","title":"ScatteringTransform.plotSecondLayerFixAndVary","text":"plotSecondLayerFixAndVary(stw, St, firstLayerWavelets, secondLayerWavelets, saveTo=\"secondLayerFigures/sliceByLayer.gif\", fps=2, index=1)\n\nCreate a GIF visualizing slices of the second layer scattering results by fixing one layer's wavelet and varying the other layer's wavelet.  The variables firstLayerWavelets and secondLayerWavelets are arrays containing the indices of the wavelets to be visualized from the first and second layers, respectively.  If firstLayerWavelets contains only one index, the function fixes that wavelet and varies the second layer wavelets, and vice versa.\n\n\n\n\n\n","category":"function"},{"location":"plots/#ScatteringTransform.plotSecondLayerSpecificPath","page":"Plotting Utilities","title":"ScatteringTransform.plotSecondLayerSpecificPath","text":"plotSecondLayerSpecificPath(stw, St, firstLayerWaveletIndex, secondLayerWaveletIndex, original, index=1)\n\nstw is the scattered output, St is the scattering transform object, firstLayerWaveletIndex and secondLayerWaveletIndex specify the path to plot, original is the original signal, and index specifies  which example in the batch to plot. This function creates a plot showing the original signal and the scattering result for the specified path. It also displays the mean frequencies associated with the  selected wavelets. Finally, it displays the log-power norm of the second layer signal for the specified path. This value is used elsewhere to create heatmaps of the second layer scattering results. \n\n\n\n\n\n","category":"function"},{"location":"math/#Mathematical-Description","page":"Mathematical Description","title":"Mathematical Description","text":"Some math f(x)=3","category":"section"},{"location":"#ScatteringTransform.jl","page":"Home","title":"ScatteringTransform.jl","text":"A julia implementation of the scattering transform, which provides a prestructured alternative to a convolutional neural network. In a similar vein to a CNN, it alternates between continuous wavelet transforms, nonlinear function applications, and subsampling. This library is end-to-end differentiable and runs on the GPU; there is a companion package, ParallelScattering.jl that runs on parallelized CPUs.\n\nThis is achieved by creating differentiable wavelet Fourier filters using FourierFilterFlux, which are then interspersed with Subsampling Operators modified from Flux.jl, and pointwise nonlinear functions (in practice, this means absolute value or ReLU).\n\nFor a comparable package in python, see Kymatio.\n\n","category":"section"},{"location":"#Basic-Example","page":"Home","title":"Basic Example","text":"As an example signal, lets work with the doppler signal:\n\nusing Wavelets, Plots\nN = 2047\nf = testfunction(N, \"Doppler\")\nplot(f, legend=false, title=\"Doppler signal\")\nsavefig(\"figures/rawDoppler.svg\"); #hide\n\n(Image: )\n\nFirst we need to make a scatteringTransform instance, which will create and store all of the necessary filters, subsampling operators, nonlinear functions, etc. The parameters are described in the scatteringTransform type. Since the Doppler signal is smooth, but with varying frequency, let's set the wavelet family cw=Morlet(π) specifies the mother wavelet to be a Morlet wavelet with mean frequency π, and frequency spacing β=2:\n\nusing ScatteringTransform, ContinuousWavelets\nSt = scatteringTransform((N, 1, 1), 2, cw=Morlet(π), β=2, σ=abs)\nsf = St(f)\n\nThe results sf are stored in the ScatteredOut type; for a two layer scattering transform, it has three output matrices (zeroth, first and second layers).","category":"section"},{"location":"#Zeroth-Layer","page":"Home","title":"Zeroth Layer","text":"The zeroth layer is simply a moving average of the original signal:\n\nplot(sf[0][:, 1, 1], title=\"Zeroth Layer\", legend=false)","category":"section"},{"location":"#First-Layer","page":"Home","title":"First Layer","text":"The first layer is the average of the absolute value of the scalogram:\n\nplotFirstLayer(sf, St, \"figures/firstLayer.png\")\nnothing # hide\n\n(Image: )\n\nWith the plotting utilities included in this package, you are able to display the previous plot along with the original signal and the first layer wavelet gradients: \n\nplotFirstLayer1DAll(sf, f, \"figures/firstLayerAll.png\")\nnothing # hide\n\n(Image: )","category":"section"},{"location":"#Second-Layer","page":"Home","title":"Second Layer","text":"The second layer is where the scattering transform begins to get more involved, and reflects both the frequency of the envelope surrounding the signal and the frequency of the signal itself. With our plotting utilities, you can display the second layer with respect to specified wavelet paths from the first and second layer. After specifying the sf and St for your plot, provide an array of the desired wavelets from the first layer and an array of the desired wavelets from the second layer.  To this end, lets make two gifs, the first with the first layer frequency varying with time:\n\nplotSecondLayerFixAndVary(sf, St, 1:30, 1, \"figures/sliceByFirst.gif\", 1)\nnothing # hide\n\n(Image: )\n\nBy fixing the first layer frequency, we get the scalogram of a single line from the scalogram above. As the first layer frequency increases, the energy concentrates to the beginning of the signal while the signal strength generally decreases.\n\nThe second has the second layer frequency varying with time:\n\nplotSecondLayerFixAndVary(sf, St, 1, 1:28, \"figures/sliceBySecond.gif\", 1)\nnothing # hide\n\n(Image: )\n\nIf desired, this package allows one to plot the results of a specific path. Here is an example, where we are plotting the resulting plot if we were to use first layer wavelet 3 and second layer wavelet 1. \n\nplotSecondLayerSpecificPath(sf, St, 3, 1, f)\nsavefig(\"figures/specificPath.png\"); #hide\n\n(Image: )\n\nFor any fixed second layer frequency, we get approximately the curve in the first layer scalogram, with different portions emphasized, and the overall mass decreasing as the frequency increases, corresponding to the decreasing amplitude of the envelope for the doppler signal. These plots can also be created using various plotting utilities defined in this package. \n\nFor example, we can generate a denser representation with the plotSecondLayer function:\n\nplotSecondLayer(sf, St)\nsavefig(\"figures/secondLayer.png\"); #hide\n\n(Image: )\n\nwhere the frequencies are along the axes, the heatmap gives the largest value across time for that path, and at each path is a small plot of the averaged timecourse.","category":"section"},{"location":"#Joint-Plot","page":"Home","title":"Joint Plot","text":"Finally, we can constuct a joint plot of much of our prior information. This plot will display the zeroth layer, first layer and second layer information for a given example. \n\njointPlot(sf, \"Scattering Transform\", :viridis, St)\nsavefig(\"figures/jointPlot.png\"); #hide\n\n(Image: )","category":"section"},{"location":"out/#ScatteredOut-type","page":"ScatteredOut type","title":"ScatteredOut type","text":"","category":"section"},{"location":"out/#ScatteredOut-Utilities","page":"ScatteredOut type","title":"ScatteredOut Utilities","text":"","category":"section"},{"location":"out/#ScatteringTransform.Scattered","page":"ScatteredOut type","title":"ScatteringTransform.Scattered","text":"Scattered{T,N}\n\nThe abstract parent type for ScatteredOut and ScatteredFull. T gives the element type for the matrices, while N gives one plus the depth of the scattering transform (so for two layers it is three).\n\n\n\n\n\n","category":"type"},{"location":"out/#ScatteringTransform.ScatteredOut","page":"ScatteredOut type","title":"ScatteringTransform.ScatteredOut","text":"A simple wrapper for the results of the scattering transform. Its one field result contains a tuple of the results from each layer, in the order zero, one, two. Say we have an example s. You can access layer i by s[i], so s[0] gives the zeroth layer\n\n\n\n\n\n","category":"type"},{"location":"out/#ScatteringTransform.flatten","page":"ScatteredOut type","title":"ScatteringTransform.flatten","text":"flatten(scatRes) -> output\n\ngiven scatRes, a scattered output or full, it produces a single vector containing the entire transform in order, i.e. the same format as output by thinSt.\n\n\n\n\n\n","category":"function"},{"location":"out/#ScatteringTransform.roll","page":"ScatteredOut type","title":"ScatteringTransform.roll","text":"roll(toRoll, st::stFlux)\n\nGiven a scattering transform st and an array toRoll that is NCoeffs×extraDims, \"roll\" up toRoll into a ScatteredOut.\n\n\n\n\n\n","category":"function"},{"location":"out/#ScatteringTransform.importantCoords","page":"ScatteredOut type","title":"ScatteringTransform.importantCoords","text":"importantCoords(scatRes)\n\ngiven a ScatteredOut scatRes, make a list that gives the largest value on each path.\n\n\n\n\n\n","category":"function"},{"location":"utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utils/#Internal-Utilities","page":"Utilities","title":"Internal Utilities","text":"","category":"section"},{"location":"utils/#ContinuousWavelets.getMeanFreq","page":"Utilities","title":"ContinuousWavelets.getMeanFreq","text":"getMeanFreq(sc::stFlux{1}, δt=1000)\n\nGet a list of the mean frequencies for the filter bank in each layer. The averaging filter is last, and gives the mean frequency of the positive frequency only. Note that δt gives the sampling rate for the input only, and that it decreases at each subsequent layer at the rate implied by the subsampling in sc.\n\njulia> using ScatteringTransform\n\njulia> St = scatteringTransform((1024,1,1),2)\n┌ Warning: there are wavelets whose peaks are far enough apart that the trough between them is less than half the height of the highest frequency wavelet\n│   minimalRegionComparedToLastPeak = 8.0292\n└ @ ContinuousWavelets ~/.julia/packages/ContinuousWavelets/KeITS/src/sanityChecks.jl:33\n┌ Warning: there are wavelets whose peaks are far enough apart that the trough between them is less than half the height of the highest frequency wavelet\n│   minimalRegionComparedToLastPeak = 9.2355\n└ @ ContinuousWavelets ~/.julia/packages/ContinuousWavelets/KeITS/src/sanityChecks.jl:33\n┌ Warning: there are wavelets whose peaks are far enough apart that the trough between them is less than half the height of the highest frequency wavelet\n│   minimalRegionComparedToLastPeak = 9.6864\n└ @ ContinuousWavelets ~/.julia/packages/ContinuousWavelets/KeITS/src/sanityChecks.jl:33\nstFlux{Nd=1, m=2, filters=[15, 14], σ = abs, batchSize = 1, normalize = true}\n\njulia> f1, f2, f3 = getMeanFreq(St);\n\njulia> f1'\n1×16 adjoint(::Vector{Float64}) with eltype Float64:\n 7.70368  54.4302  78.7967  …  315.712  338.416  6.36036\njulia> f2'\n1×15 adjoint(::Vector{Float64}) with eltype Float64:\n 10.8253  64.1205  89.7788  …  296.729  317.265  8.94436\n\n\n\n\n\n","category":"function"},{"location":"utils/#ScatteringTransform.getWavelets","page":"Utilities","title":"ScatteringTransform.getWavelets","text":"getWavelets(sc::stFlux; spaceDomain=false) -> wave1, wave2, wave3, ...\n\nGet the wavelets used in each layer. If spaceDomain is true, then it will also convert the filters from the stored positive Fourier representation to a space version.\n\n\n\n\n\n","category":"function"},{"location":"utils/#ScatteringTransform.depth","page":"Utilities","title":"ScatteringTransform.depth","text":"depth(s::scatteringTransform{Dim,Depth})\n\ngiven a scattering transform, return the number of layers Depth.\n\n\n\n\n\n","category":"function"},{"location":"utils/#Base.ndims","page":"Utilities","title":"Base.ndims","text":"ndims(s::scatteringTransform{D})\n\ngiven a scattering transform s, return the number of layers Depth.\n\n\n\n\n\nndims(sct::Scattered)\n\nreturn the input dimension size (also given by sct.k)\n\n\n\n\n\nndims(r::MaxPool{N,M})\nndims(r::MeanPool{N,M})\n\nreturn the dimension N of the input signal\n\n\n\n\n\n","category":"function"},{"location":"utils/#ScatteringTransform.batchOff","page":"Utilities","title":"ScatteringTransform.batchOff","text":"batchOff(stack, x, batchSize)\n\ntransform x using stack, but where x and stack may have different batch sizes (the final dimension).\n\n\n\n\n\n","category":"function"},{"location":"utils/#ScatteringTransform.normalize","page":"Utilities","title":"ScatteringTransform.normalize","text":"normalize(x, Nd) -> normedX\n\nnormalize x over the dimensions Nd through ndims(x)-1. For example, if Nd=2, and x is 4D, then norm(normedX[:,:,:,j], 2) ≈ size(normedX,3).\n\n\n\n\n\n","category":"function"},{"location":"utils/#ScatteringTransform.processArgs","page":"Utilities","title":"ScatteringTransform.processArgs","text":"processArgs(m, varargs) -> listVargs\n\nGo from arguments given to the scattering transform constructor to those for the wavelet or frame transform. listVargs is a list of length m of one argument from each of vargs, with insufficiently long entries filled in by repeating the last value. For a list of these arguments, see the documentation for stFlux.\n\nExamples\n\njulia> using ContinuousWavelets, ScatteringTransform\n\njulia> varargs = ( :boundary      => PerBoundary(), :frameBound    => [1, 1], :normalization => (Inf, Inf))\n(:boundary => PerBoundary(), :frameBound => [1, 1], :normalization => (Inf, Inf))\n\njulia> varargs\n(:boundary => PerBoundary(), :frameBound => [1, 1], :normalization => (Inf, Inf))\n\njulia> listVargs = ScatteringTransform.processArgs(3,varargs)\n(Base.Pairs{Int64, Pair{Symbol}, Base.OneTo{Int64}, Tuple{Pair{Symbol, PerBoundary}, Pair{Symbol, Vector{Int64}}, Pair{Symbol, Tuple{Float64, Float64}}}}(1 => (:boundary => PerBoundary()), 2 => (:frameBound => [1, 1]), 3 => (:normalization => (Inf, Inf))), Base.Pairs{Int64, Pair{Symbol}, Base.OneTo{Int64}, Tuple{Pair{Symbol, PerBoundary}, Pair{Symbol, Vector{Int64}}, Pair{Symbol, Tuple{Float64, Float64}}}}(1 => (:boundary => PerBoundary()), 2 => (:frameBound => [1, 1]), 3 => (:normalization => (Inf, Inf))), Base.Pairs{Int64, Pair{Symbol}, Base.OneTo{Int64}, Tuple{Pair{Symbol, PerBoundary}, Pair{Symbol, Vector{Int64}}, Pair{Symbol, Tuple{Float64, Float64}}}}(1 => (:boundary => PerBoundary()), 2 => (:frameBound => [1, 1]), 3 => (:normalization => (Inf, Inf))))\n\njulia> listVargs[1]\npairs(::Tuple{Pair{Symbol, ContinuousWavelets.PerBoundary}, Pair{Symbol, Vector{Int64}}, Pair{Symbol, Tuple{Float64, Float64}}}) with 3 entries:\n  1 => :boundary=>PerBoundary()\n  2 => :frameBound=>[1, 1]\n  3 => :normalization=>(Inf, Inf)\n\njulia> listVargs[2]\npairs(::Tuple{Pair{Symbol, ContinuousWavelets.PerBoundary}, Pair{Symbol, Vector{Int64}}, Pair{Symbol, Tuple{Float64, Float64}}}) with 3 entries:\n  1 => :boundary=>PerBoundary()\n  2 => :frameBound=>[1, 1]\n  3 => :normalization=>(Inf, Inf)\n\njulia> listVargs[3]\npairs(::Tuple{Pair{Symbol, ContinuousWavelets.PerBoundary}, Pair{Symbol, Vector{Int64}}, Pair{Symbol, Tuple{Float64, Float64}}}) with 3 entries:\n  1 => :boundary=>PerBoundary()\n  2 => :frameBound=>[1, 1]\n  3 => :normalization=>(Inf, Inf)\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#ScatteringTransform.getParameters","page":"Utilities","title":"ScatteringTransform.getParameters","text":"getParameters(st, s)\n\ngiven a scatteringTransform object and a symbol s representing a possible keyword, e.g. :Q, or :β, return the value for this transform. It may be in st.settings, or, if it is a default value, it is looked up.\n\n\n\n\n\n","category":"function"},{"location":"utils/#ScatteringTransform.extractAddPadding","page":"Utilities","title":"ScatteringTransform.extractAddPadding","text":"extractAddPadding(x, adr, chunkSize, N)\n\nFrom x, extract the examples adr in the last dimension, and make sure that it has a size of chunkSize, padding if there are too few examples (this is to make sure the batch size matches).\n\n\n\n\n\n","category":"function"}]
}
